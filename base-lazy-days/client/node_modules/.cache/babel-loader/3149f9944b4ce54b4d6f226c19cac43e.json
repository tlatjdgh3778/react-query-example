{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\n// eslint-disable-next-line import/no-unresolved\nimport { useCustomToast } from 'components/app/hooks/useCustomToast';\nimport jsonpatch from 'fast-json-patch';\n// eslint-disable-next-line import/no-unresolved\nimport { queryKeys } from 'react-query/constants';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { useUser } from './useUser';\n\n// for when we need a server function\nasync function patchUserOnServer(newData, originalData) {\n  if (!newData || !originalData) return null;\n  // create a patch for the difference between newData and originalData\n  const patch = jsonpatch.compare(originalData, newData);\n\n  // send patched data to the server\n  const {\n    data\n  } = await axiosInstance.patch(`/user/${originalData.id}`, {\n    patch\n  }, {\n    headers: getJWTHeader(originalData)\n  });\n  return data.user;\n}\n\n// TODO: update type to UseMutateFunction type\nexport function usePatchUser() {\n  _s();\n  const {\n    user,\n    updateUser\n  } = useUser();\n  const toast = useCustomToast();\n  const queryClient = useQueryClient();\n  const {\n    mutate: patchUser\n  } = useMutation(newUserData => patchUserOnServer(newUserData, user), {\n    onMutate: async newData => {\n      // 쿼리 취소\n      // 낙관적 업데이트를 덮어쓰지 않게\n      queryClient.cancelQueries(queryKeys.user);\n      // 기존 사용자 데이터의 스냅샷을 찍음(가져옴)\n      const prevUserData = queryClient.getQueryData(queryKeys.user);\n      // 새로운 값으로 캐시를 업데이트(낙관적 업데이트)\n      updateUser(newData);\n      // 이후 해당 컨텍스트를 반환한다.\n      return {\n        prevUserData\n      };\n    },\n    // onError가 위에서 반환한 컨텍스트를 받음\n    onError: (error, newData, context) => {\n      // 롤백한다.\n      if (context.prevUserData) {\n        updateUser(context.prevUserData);\n        toast({\n          title: '업데이트에 실패해서 이전 데이터를 보여줍니다.',\n          status: 'warning'\n        });\n      }\n    },\n    onSuccess: userData => {\n      updateUser(userData);\n      if (user) {\n        toast({\n          title: 'User updated!',\n          status: 'success'\n        });\n      }\n    },\n    // 무조건 실행되는 부분\n    onSettled: () => {\n      // 쿼리 무효화 후 서버에서 최신 데이터를 받아오는 부분\n      queryClient.invalidateQueries(queryKeys.user);\n    }\n  });\n  return patchUser;\n}\n_s(usePatchUser, \"7cj5AKVt9P+SDRO7AdycYdtc0IE=\", false, function () {\n  return [useUser, useCustomToast, useQueryClient, useMutation];\n});","map":{"version":3,"names":["useMutation","useQueryClient","useCustomToast","jsonpatch","queryKeys","axiosInstance","getJWTHeader","useUser","patchUserOnServer","newData","originalData","patch","compare","data","id","headers","user","usePatchUser","updateUser","toast","queryClient","mutate","patchUser","newUserData","onMutate","cancelQueries","prevUserData","getQueryData","onError","error","context","title","status","onSuccess","userData","onSettled","invalidateQueries"],"sources":["C:/Users/tjdgh/Desktop/study/react-query/react-query-example/base-lazy-days/client/src/components/user/hooks/usePatchUser.ts"],"sourcesContent":["import {\n  UseMutateFunction,\n  useMutation,\n  useQueryClient,\n} from '@tanstack/react-query';\n// eslint-disable-next-line import/no-unresolved\nimport { useCustomToast } from 'components/app/hooks/useCustomToast';\nimport jsonpatch from 'fast-json-patch';\n// eslint-disable-next-line import/no-unresolved\nimport { queryKeys } from 'react-query/constants';\n\nimport type { User } from '../../../../../shared/types';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { useUser } from './useUser';\n\n// for when we need a server function\nasync function patchUserOnServer(\n  newData: User | null,\n  originalData: User | null,\n): Promise<User | null> {\n  if (!newData || !originalData) return null;\n  // create a patch for the difference between newData and originalData\n  const patch = jsonpatch.compare(originalData, newData);\n\n  // send patched data to the server\n  const { data } = await axiosInstance.patch(\n    `/user/${originalData.id}`,\n    { patch },\n    {\n      headers: getJWTHeader(originalData),\n    },\n  );\n  return data.user;\n}\n\n// TODO: update type to UseMutateFunction type\nexport function usePatchUser(): UseMutateFunction<\n  User,\n  unknown,\n  User,\n  unknown\n> {\n  const { user, updateUser } = useUser();\n  const toast = useCustomToast();\n  const queryClient = useQueryClient();\n  const { mutate: patchUser } = useMutation(\n    (newUserData: User) => patchUserOnServer(newUserData, user),\n    {\n      onMutate: async (newData: User | null) => {\n        // 쿼리 취소\n        // 낙관적 업데이트를 덮어쓰지 않게\n        queryClient.cancelQueries(queryKeys.user);\n        // 기존 사용자 데이터의 스냅샷을 찍음(가져옴)\n        const prevUserData: User = queryClient.getQueryData(queryKeys.user);\n        // 새로운 값으로 캐시를 업데이트(낙관적 업데이트)\n        updateUser(newData);\n        // 이후 해당 컨텍스트를 반환한다.\n        return { prevUserData };\n      },\n      // onError가 위에서 반환한 컨텍스트를 받음\n      onError: (error, newData, context) => {\n        // 롤백한다.\n        if (context.prevUserData) {\n          updateUser(context.prevUserData);\n          toast({\n            title: '업데이트에 실패해서 이전 데이터를 보여줍니다.',\n            status: 'warning',\n          });\n        }\n      },\n      onSuccess: (userData: User | null) => {\n        updateUser(userData);\n        if (user) {\n          toast({\n            title: 'User updated!',\n            status: 'success',\n          });\n        }\n      },\n      // 무조건 실행되는 부분\n      onSettled: () => {\n        // 쿼리 무효화 후 서버에서 최신 데이터를 받아오는 부분\n        queryClient.invalidateQueries(queryKeys.user);\n      },\n    },\n  );\n  return patchUser;\n}\n"],"mappings":";AAAA,SAEEA,WAAW,EACXC,cAAc,QACT,uBAAuB;AAC9B;AACA,SAASC,cAAc,QAAQ,qCAAqC;AACpE,OAAOC,SAAS,MAAM,iBAAiB;AACvC;AACA,SAASC,SAAS,QAAQ,uBAAuB;AAGjD,SAASC,aAAa,EAAEC,YAAY,QAAQ,wBAAwB;AACpE,SAASC,OAAO,QAAQ,WAAW;;AAEnC;AACA,eAAeC,iBAAiB,CAC9BC,OAAoB,EACpBC,YAAyB,EACH;EACtB,IAAI,CAACD,OAAO,IAAI,CAACC,YAAY,EAAE,OAAO,IAAI;EAC1C;EACA,MAAMC,KAAK,GAAGR,SAAS,CAACS,OAAO,CAACF,YAAY,EAAED,OAAO,CAAC;;EAEtD;EACA,MAAM;IAAEI;EAAK,CAAC,GAAG,MAAMR,aAAa,CAACM,KAAK,CACvC,SAAQD,YAAY,CAACI,EAAG,EAAC,EAC1B;IAAEH;EAAM,CAAC,EACT;IACEI,OAAO,EAAET,YAAY,CAACI,YAAY;EACpC,CAAC,CACF;EACD,OAAOG,IAAI,CAACG,IAAI;AAClB;;AAEA;AACA,OAAO,SAASC,YAAY,GAK1B;EAAA;EACA,MAAM;IAAED,IAAI;IAAEE;EAAW,CAAC,GAAGX,OAAO,EAAE;EACtC,MAAMY,KAAK,GAAGjB,cAAc,EAAE;EAC9B,MAAMkB,WAAW,GAAGnB,cAAc,EAAE;EACpC,MAAM;IAAEoB,MAAM,EAAEC;EAAU,CAAC,GAAGtB,WAAW,CACtCuB,WAAiB,IAAKf,iBAAiB,CAACe,WAAW,EAAEP,IAAI,CAAC,EAC3D;IACEQ,QAAQ,EAAE,MAAOf,OAAoB,IAAK;MACxC;MACA;MACAW,WAAW,CAACK,aAAa,CAACrB,SAAS,CAACY,IAAI,CAAC;MACzC;MACA,MAAMU,YAAkB,GAAGN,WAAW,CAACO,YAAY,CAACvB,SAAS,CAACY,IAAI,CAAC;MACnE;MACAE,UAAU,CAACT,OAAO,CAAC;MACnB;MACA,OAAO;QAAEiB;MAAa,CAAC;IACzB,CAAC;IACD;IACAE,OAAO,EAAE,CAACC,KAAK,EAAEpB,OAAO,EAAEqB,OAAO,KAAK;MACpC;MACA,IAAIA,OAAO,CAACJ,YAAY,EAAE;QACxBR,UAAU,CAACY,OAAO,CAACJ,YAAY,CAAC;QAChCP,KAAK,CAAC;UACJY,KAAK,EAAE,2BAA2B;UAClCC,MAAM,EAAE;QACV,CAAC,CAAC;MACJ;IACF,CAAC;IACDC,SAAS,EAAGC,QAAqB,IAAK;MACpChB,UAAU,CAACgB,QAAQ,CAAC;MACpB,IAAIlB,IAAI,EAAE;QACRG,KAAK,CAAC;UACJY,KAAK,EAAE,eAAe;UACtBC,MAAM,EAAE;QACV,CAAC,CAAC;MACJ;IACF,CAAC;IACD;IACAG,SAAS,EAAE,MAAM;MACf;MACAf,WAAW,CAACgB,iBAAiB,CAAChC,SAAS,CAACY,IAAI,CAAC;IAC/C;EACF,CAAC,CACF;EACD,OAAOM,SAAS;AAClB;AAAC,GAnDeL,YAAY;EAAA,QAMGV,OAAO,EACtBL,cAAc,EACRD,cAAc,EACJD,WAAW;AAAA"},"metadata":{},"sourceType":"module"}