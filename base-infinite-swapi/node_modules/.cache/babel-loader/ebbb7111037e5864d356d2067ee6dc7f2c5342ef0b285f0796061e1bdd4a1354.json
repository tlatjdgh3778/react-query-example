{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nimport { isBigint, isDate, isInfinite, isMap, isNaNValue, isRegExp, isSet, isUndefined, isSymbol, isArray, isError, isTypedArray, isURL } from './is';\nimport { findArr } from './util';\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\nvar simpleRules = [simpleTransformation(isUndefined, 'undefined', function () {\n  return null;\n}, function () {\n  return undefined;\n}), simpleTransformation(isBigint, 'bigint', function (v) {\n  return v.toString();\n}, function (v) {\n  if (typeof BigInt !== 'undefined') {\n    return BigInt(v);\n  }\n  console.error('Please add a BigInt polyfill.');\n  return v;\n}), simpleTransformation(isDate, 'Date', function (v) {\n  return v.toISOString();\n}, function (v) {\n  return new Date(v);\n}), simpleTransformation(isError, 'Error', function (v, superJson) {\n  var baseError = {\n    name: v.name,\n    message: v.message\n  };\n  superJson.allowedErrorProps.forEach(function (prop) {\n    baseError[prop] = v[prop];\n  });\n  return baseError;\n}, function (v, superJson) {\n  var e = new Error(v.message);\n  e.name = v.name;\n  e.stack = v.stack;\n  superJson.allowedErrorProps.forEach(function (prop) {\n    e[prop] = v[prop];\n  });\n  return e;\n}), simpleTransformation(isRegExp, 'regexp', function (v) {\n  return '' + v;\n}, function (regex) {\n  var body = regex.slice(1, regex.lastIndexOf('/'));\n  var flags = regex.slice(regex.lastIndexOf('/') + 1);\n  return new RegExp(body, flags);\n}), simpleTransformation(isSet, 'set',\n// (sets only exist in es6+)\n// eslint-disable-next-line es5/no-es6-methods\nfunction (v) {\n  return __spreadArray([], __read(v.values()));\n}, function (v) {\n  return new Set(v);\n}), simpleTransformation(isMap, 'map', function (v) {\n  return __spreadArray([], __read(v.entries()));\n}, function (v) {\n  return new Map(v);\n}), simpleTransformation(function (v) {\n  return isNaNValue(v) || isInfinite(v);\n}, 'number', function (v) {\n  if (isNaNValue(v)) {\n    return 'NaN';\n  }\n  if (v > 0) {\n    return 'Infinity';\n  } else {\n    return '-Infinity';\n  }\n}, Number), simpleTransformation(function (v) {\n  return v === 0 && 1 / v === -Infinity;\n}, 'number', function () {\n  return '-0';\n}, Number), simpleTransformation(isURL, 'URL', function (v) {\n  return v.toString();\n}, function (v) {\n  return new URL(v);\n})];\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable: isApplicable,\n    annotation: annotation,\n    transform: transform,\n    untransform: untransform\n  };\n}\nvar symbolRule = compositeTransformation(function (s, superJson) {\n  if (isSymbol(s)) {\n    var isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n    return isRegistered;\n  }\n  return false;\n}, function (s, superJson) {\n  var identifier = superJson.symbolRegistry.getIdentifier(s);\n  return ['symbol', identifier];\n}, function (v) {\n  return v.description;\n}, function (_, a, superJson) {\n  var value = superJson.symbolRegistry.getValue(a[1]);\n  if (!value) {\n    throw new Error('Trying to deserialize unknown symbol');\n  }\n  return value;\n});\nvar constructorToName = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Uint8ClampedArray].reduce(function (obj, ctor) {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\nvar typedArrayRule = compositeTransformation(isTypedArray, function (v) {\n  return ['typed-array', v.constructor.name];\n}, function (v) {\n  return __spreadArray([], __read(v));\n}, function (v, a) {\n  var ctor = constructorToName[a[1]];\n  if (!ctor) {\n    throw new Error('Trying to deserialize unknown typed array');\n  }\n  return new ctor(v);\n});\nexport function isInstanceOfRegisteredClass(potentialClass, superJson) {\n  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {\n    var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);\n    return isRegistered;\n  }\n  return false;\n}\nvar classRule = compositeTransformation(isInstanceOfRegisteredClass, function (clazz, superJson) {\n  var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n  return ['class', identifier];\n}, function (clazz, superJson) {\n  var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);\n  if (!allowedProps) {\n    return __assign({}, clazz);\n  }\n  var result = {};\n  allowedProps.forEach(function (prop) {\n    result[prop] = clazz[prop];\n  });\n  return result;\n}, function (v, a, superJson) {\n  var clazz = superJson.classRegistry.getValue(a[1]);\n  if (!clazz) {\n    throw new Error('Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564');\n  }\n  return Object.assign(Object.create(clazz.prototype), v);\n});\nvar customRule = compositeTransformation(function (value, superJson) {\n  return !!superJson.customTransformerRegistry.findApplicable(value);\n}, function (value, superJson) {\n  var transformer = superJson.customTransformerRegistry.findApplicable(value);\n  return ['custom', transformer.name];\n}, function (value, superJson) {\n  var transformer = superJson.customTransformerRegistry.findApplicable(value);\n  return transformer.serialize(value);\n}, function (v, a, superJson) {\n  var transformer = superJson.customTransformerRegistry.findByName(a[1]);\n  if (!transformer) {\n    throw new Error('Trying to deserialize unknown custom value');\n  }\n  return transformer.deserialize(v);\n});\nvar compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\nexport var transformValue = function (value, superJson) {\n  var applicableCompositeRule = findArr(compositeRules, function (rule) {\n    return rule.isApplicable(value, superJson);\n  });\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value, superJson),\n      type: applicableCompositeRule.annotation(value, superJson)\n    };\n  }\n  var applicableSimpleRule = findArr(simpleRules, function (rule) {\n    return rule.isApplicable(value, superJson);\n  });\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value, superJson),\n      type: applicableSimpleRule.annotation\n    };\n  }\n  return undefined;\n};\nvar simpleRulesByAnnotation = {};\nsimpleRules.forEach(function (rule) {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\nexport var untransformValue = function (json, type, superJson) {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type, superJson);\n      case 'class':\n        return classRule.untransform(json, type, superJson);\n      case 'custom':\n        return customRule.untransform(json, type, superJson);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type, superJson);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    var transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n    return transformation.untransform(json, superJson);\n  }\n};","map":{"version":3,"mappings":"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","names":["isBigint","isDate","isInfinite","isMap","isNaNValue","isRegExp","isSet","isUndefined","isSymbol","isArray","isError","isTypedArray","isURL","findArr","simpleTransformation","isApplicable","annotation","transform","untransform","simpleRules","toString","BigInt","v","console","error","toISOString","Date","superJson","baseError","name","message","allowedErrorProps","forEach","prop","e","Error","stack","body","regex","slice","lastIndexOf","flags","RegExp","values","Set","entries","Map","Number","Infinity","URL","compositeTransformation","symbolRule","s","isRegistered","symbolRegistry","getIdentifier","identifier","description","_","a","value","getValue","constructorToName","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Uint8ClampedArray","reduce","obj","ctor","typedArrayRule","constructor","isInstanceOfRegisteredClass","potentialClass","classRegistry","classRule","clazz","allowedProps","getAllowedProps","result","Object","assign","create","prototype","customRule","customTransformerRegistry","findApplicable","transformer","serialize","findByName","deserialize","compositeRules","transformValue","applicableCompositeRule","type","applicableSimpleRule","undefined","simpleRulesByAnnotation","rule","untransformValue","json","transformation"],"sources":["C:\\Users\\tjdgh\\Desktop\\study\\react-query\\react-query-example\\base-infinite-swapi\\node_modules\\superjson\\src\\transformer.ts"],"sourcesContent":["import {\n  isBigint,\n  isDate,\n  isInfinite,\n  isMap,\n  isNaNValue,\n  isRegExp,\n  isSet,\n  isUndefined,\n  isSymbol,\n  isArray,\n  isError,\n  isTypedArray,\n  TypedArrayConstructor,\n  isURL,\n} from './is';\nimport { findArr } from './util';\nimport SuperJSON from '.';\n\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\n\ntype LeafTypeAnnotation =\n  | PrimitiveTypeAnnotation\n  | 'regexp'\n  | 'Date'\n  | 'Error'\n  | 'URL';\n\ntype TypedArrayAnnotation = ['typed-array', string];\ntype ClassTypeAnnotation = ['class', string];\ntype SymbolTypeAnnotation = ['symbol', string];\ntype CustomTypeAnnotation = ['custom', string];\n\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\n\ntype CompositeTypeAnnotation =\n  | TypedArrayAnnotation\n  | ClassTypeAnnotation\n  | SymbolTypeAnnotation\n  | CustomTypeAnnotation;\n\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\n\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\n  annotation: A,\n  transform: (v: I, superJson: SuperJSON) => O,\n  untransform: (v: O, superJson: SuperJSON) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst simpleRules = [\n  simpleTransformation(\n    isUndefined,\n    'undefined',\n    () => null,\n    () => undefined\n  ),\n  simpleTransformation(\n    isBigint,\n    'bigint',\n    v => v.toString(),\n    v => {\n      if (typeof BigInt !== 'undefined') {\n        return BigInt(v);\n      }\n\n      console.error('Please add a BigInt polyfill.');\n\n      return v as any;\n    }\n  ),\n  simpleTransformation(\n    isDate,\n    'Date',\n    v => v.toISOString(),\n    v => new Date(v)\n  ),\n\n  simpleTransformation(\n    isError,\n    'Error',\n    (v, superJson) => {\n      const baseError: any = {\n        name: v.name,\n        message: v.message,\n      };\n\n      superJson.allowedErrorProps.forEach(prop => {\n        baseError[prop] = (v as any)[prop];\n      });\n\n      return baseError;\n    },\n    (v, superJson) => {\n      const e = new Error(v.message);\n      e.name = v.name;\n      e.stack = v.stack;\n\n      superJson.allowedErrorProps.forEach(prop => {\n        (e as any)[prop] = v[prop];\n      });\n\n      return e;\n    }\n  ),\n\n  simpleTransformation(\n    isRegExp,\n    'regexp',\n    v => '' + v,\n    regex => {\n      const body = regex.slice(1, regex.lastIndexOf('/'));\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\n      return new RegExp(body, flags);\n    }\n  ),\n\n  simpleTransformation(\n    isSet,\n    'set',\n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    v => [...v.values()],\n    v => new Set(v)\n  ),\n  simpleTransformation(\n    isMap,\n    'map',\n    v => [...v.entries()],\n    v => new Map(v)\n  ),\n\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\n    (v): v is number => isNaNValue(v) || isInfinite(v),\n    'number',\n    v => {\n      if (isNaNValue(v)) {\n        return 'NaN';\n      }\n\n      if (v > 0) {\n        return 'Infinity';\n      } else {\n        return '-Infinity';\n      }\n    },\n    Number\n  ),\n\n  simpleTransformation<number, '-0', 'number'>(\n    (v): v is number => v === 0 && 1 / v === -Infinity,\n    'number',\n    () => {\n      return '-0';\n    },\n    Number\n  ),\n\n  simpleTransformation(\n    isURL,\n    'URL',\n    v => v.toString(),\n    v => new URL(v)\n  ),\n];\n\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\n  annotation: (v: I, superJson: SuperJSON) => A,\n  transform: (v: I, superJson: SuperJSON) => O,\n  untransform: (v: O, a: A, superJson: SuperJSON) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst symbolRule = compositeTransformation(\n  (s, superJson): s is Symbol => {\n    if (isSymbol(s)) {\n      const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n      return isRegistered;\n    }\n    return false;\n  },\n  (s, superJson) => {\n    const identifier = superJson.symbolRegistry.getIdentifier(s);\n    return ['symbol', identifier!];\n  },\n  v => v.description,\n  (_, a, superJson) => {\n    const value = superJson.symbolRegistry.getValue(a[1]);\n    if (!value) {\n      throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n  }\n);\n\nconst constructorToName = [\n  Int8Array,\n  Uint8Array,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  Uint8ClampedArray,\n].reduce<Record<string, TypedArrayConstructor>>((obj, ctor) => {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\n\nconst typedArrayRule = compositeTransformation(\n  isTypedArray,\n  v => ['typed-array', v.constructor.name],\n  v => [...v],\n  (v, a) => {\n    const ctor = constructorToName[a[1]];\n\n    if (!ctor) {\n      throw new Error('Trying to deserialize unknown typed array');\n    }\n\n    return new ctor(v);\n  }\n);\n\nexport function isInstanceOfRegisteredClass(\n  potentialClass: any,\n  superJson: SuperJSON\n): potentialClass is any {\n  if (potentialClass?.constructor) {\n    const isRegistered = !!superJson.classRegistry.getIdentifier(\n      potentialClass.constructor\n    );\n    return isRegistered;\n  }\n  return false;\n}\n\nconst classRule = compositeTransformation(\n  isInstanceOfRegisteredClass,\n  (clazz, superJson) => {\n    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier!];\n  },\n  (clazz, superJson) => {\n    const allowedProps = superJson.classRegistry.getAllowedProps(\n      clazz.constructor\n    );\n    if (!allowedProps) {\n      return { ...clazz };\n    }\n\n    const result: any = {};\n    allowedProps.forEach(prop => {\n      result[prop] = clazz[prop];\n    });\n    return result;\n  },\n  (v, a, superJson) => {\n    const clazz = superJson.classRegistry.getValue(a[1]);\n\n    if (!clazz) {\n      throw new Error(\n        'Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564'\n      );\n    }\n\n    return Object.assign(Object.create(clazz.prototype), v);\n  }\n);\n\nconst customRule = compositeTransformation(\n  (value, superJson): value is any => {\n    return !!superJson.customTransformerRegistry.findApplicable(value);\n  },\n  (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(\n      value\n    )!;\n    return ['custom', transformer.name];\n  },\n  (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(\n      value\n    )!;\n    return transformer.serialize(value);\n  },\n  (v, a, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findByName(a[1]);\n    if (!transformer) {\n      throw new Error('Trying to deserialize unknown custom value');\n    }\n    return transformer.deserialize(v);\n  }\n);\n\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\n\nexport const transformValue = (\n  value: any,\n  superJson: SuperJSON\n): { value: any; type: TypeAnnotation } | undefined => {\n  const applicableCompositeRule = findArr(compositeRules, rule =>\n    rule.isApplicable(value, superJson)\n  );\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value as never, superJson),\n      type: applicableCompositeRule.annotation(value, superJson),\n    };\n  }\n\n  const applicableSimpleRule = findArr(simpleRules, rule =>\n    rule.isApplicable(value, superJson)\n  );\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value as never, superJson),\n      type: applicableSimpleRule.annotation,\n    };\n  }\n\n  return undefined;\n};\n\nconst simpleRulesByAnnotation: Record<string, typeof simpleRules[0]> = {};\nsimpleRules.forEach(rule => {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\n\nexport const untransformValue = (\n  json: any,\n  type: TypeAnnotation,\n  superJson: SuperJSON\n) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type, superJson);\n      case 'class':\n        return classRule.untransform(json, type, superJson);\n      case 'custom':\n        return customRule.untransform(json, type, superJson);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type, superJson);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json as never, superJson);\n  }\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}